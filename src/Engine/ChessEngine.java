/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */

// todo: 
// check for stalemate when king and 2? other pieces remain
// prune moves that cause a major point loss (700?), re-search if no better moves are available (enhancement of alpha beta)
// introduce randomization into opening book so the same game is not always played if two engines were to play each other.
// find better background thread method than SwingWorker

package com.circumspectus.Engine;

import java.util.ArrayList;
import com.circumspectus.ChessApplication.*;
import com.circumspectus.PGN.PGNGame;
import com.circumspectus.PGN.PGNGameTreeLookup;
import com.circumspectus.PGN.MoveResults;
import com.circumspectus.Engine.TranspositionFields.TypeOfScore;
import java.util.Collections;
import java.util.Comparator;

/**
 * A chess engine to generate optimal moves given a present board.  
 * Uses alpha beta pruning within the negamax framework (depth first).
 * Uses iterative deepening for optimal move ordering, and to return a best move at the end of a specified time period or after an interrupt
 * Utilizes killer move table and transposition tables for optimal move ordering.
 * Includes quiescence search.
 * @author Christopher Stieg
 */
public class ChessEngine {
    private boolean displaySearchBoard;
    private final ZobristBoard board;  // the main game board
    private ZobristBoard searchBoard; // a board on which to perform searches
    private final static int INITIAL_DEPTH = 2;  // initial search depth in iterative deepening
    final static int DEPTH = 40; // search depth in ply
    private final static int ADDITIONAL_DEPTH_FOR_QUIESCENCE = 4; 
    private final int allowedProcessingTime = 30 * 1000;
    private boolean interrupted;  // true causes engine to cascade down and return the next move immediately
    private boolean running;  // true while the engine is running, used to verify that the engine is not running before it is used for idle time processing
    
    private final static double DRAW_MULTIPLIER = 0.45;  // the fraction of a win that a draw is considered.  If set at 0.5, a record of 10W 10L 10D would be considered just as desirable
    // as 15W 15L 0D.  The lower the multiplier is set, the more the AI plays aggressively to win while risking losses, rather than
    // playing safe.  Could be set higher to play for a win or a draw against higher ranked opponents, or set lower against
    // lower ranked opponents.
    private final static int DRAW_VALUE = -400;  // the relative evaluation of a draw.  Set below 0 to encourage aggressive play, possibly set above 0 when playing against a higher rated opponent, or 
                                                 // in a match when only a draw is needed
    private final static int MOBILITY_MULTIPLIER = 5; // value in centipawns per number of possibles moves
    private final static int CONNECTIVITY_MULTIPLIER = 4;  // additional value for defending one's own pieces
    private final static int ATTACK_MULTIPLIER = 5;  // additional value for attacking enemy pieces
    private final static int CENTER4_MULTIPLIER = 4; // bonus per square for controlling center 4 squares
    private final static int CENTER16_MULTIPLIER = 2; // bonus per square for controlling center 16 squares
    private BoardRenderer searchBoardRenderer;  // a renderer to draw the search board for debugging purposes
    private final KillerMoveHistoryTable killerMoveHistoryTable;  // keeps a count of how many times each moves causes a cutoff in alpha-beta
    private final MoveComparator moveComparator;  
    private final MoveComparator moveComparatorNoHistory;  // comparator used for move ordering in quiescence, which doesn't take into account killer moves, since captures are not included in the killer move table
    private final TranspositionTable transpositionTable;  // stores results of each board position generated by search
    private TranspositionFields transpositionFields;  // return tuple for transposition table
    private final static int ACCEPTABLE_LOSS_OF_DEPTH_IN_TRANSPOSITION = 0;
    
    private static final int DOUBLE_BISHOP_BONUS = 50; 
    private static final int DOUBLED_PAWN_PENALTY = 47;
    private static final int ISOLATED_PAWN_PENALTY = 24;
    private static final int PASSED_PAWN_BONUS = 150;
    private static final int PAWN_SHIELD_BONUS = 15;
    private static final int SQUARE_ADJACENT_TO_KING_ATTACKED_PENALTY = 10;
    private static final int BOTH_CASTLING_RIGHTS_VALUE = 25;
    private static final int ONE_CASTLING_RIGHTS_VALUE = 20;

    // bonuses by piece/square to encourage good piece placement and pawn advancement
    private static final int WHITE_PAWN_BONUSES[] =  {  0,  0,  0,  0,  0,  0,  0,  0,
                                                        5,  10, 10, -20,-20,10, 10, 5,
                                                        0,  -5, -10,0,  0,  -10,-5, 0,
                                                        0,  0,  7,  20, 20, 7,  0,  0,
                                                        25, 25, 30, 50, 50, 30, 25, 25,
                                                        75, 75, 100,125,125,100,75, 75,
                                                        230,230,230,230,230,230,230,230,
                                                        0,  0,  0,  0,  0,  0,  0,  0 };
                                                        
    private static final int BLACK_PAWN_BONUSES[] =  {  0,  0,  0,  0,  0,  0,  0,  0,
                                                        230,230,230,230,230,230,230,230,
                                                        75, 75, 100,125,125,100,75, 75,
                                                        25, 25, 30, 50, 50, 30, 25, 25,
                                                        0,  0,  7,  20, 20, 7,  0,  0,
                                                        0,  -5, -10,0,  0,  -10,-5, 0,
                                                        5,  10, 10, -20,-20,10, 10, 5,
                                                        0,  0,  0,  0,  0,  0,  0,  0 };
    
    private static final int WHITE_KNIGHT_BONUSES[] = { -50,-40,-30,-30,-30,-30,-40,-50,
                                                        -40,-20,0,  5,  5,  0,  -20,-40,
                                                        -30,5,  10, 15, 15, 10, 5,  -30,
                                                        -30,0,  15, 20, 20, 15, 0,  -30,
                                                        -30,5,  15, 20, 20, 15, 5,  -30,
                                                        -30,0,  10, 15, 15, 10, 0,  -30,
                                                        -40,-20,0,  0,  0,  0,  -20,-40,
                                                        -50,-40,-30,-30,-30,-30,-40,-50 };
    
    private static final int BLACK_KNIGHT_BONUSES[] = { -50,-40,-30,-30,-30,-30,-40,-50,
                                                        -40,-20,0,  0,  0,  0,  -20,-40,
                                                        -30,0,  10, 15, 15, 10, 0,  -30,
                                                        -30,5,  15, 20, 20, 15, 5,  -30,
                                                        -30,0,  15, 20, 20, 15, 0,  -30,
                                                        -30,5,  10, 15, 15, 10, 5,  -30,
                                                        -40,-20,0,  5,  5,  0,  -20,-40,
                                                        -50,-40,-30,-30,-30,-30,-40,-50 };
                                                    
    private static final int WHITE_BISHOP_BONUSES[] = { -20,-15,-15,-15,-15,-15,-15,-20,
                                                        -10,  5,  0,  0,  0,  0,  5,-10,
                                                        -10, 10, 10, 10, 10, 10, 10,-10,
                                                        -10,  0, 10, 10, 10, 10,  0,-10,
                                                        -10,  5,  5, 10, 10,  5,  5,-10,
                                                        -10,  0,  5, 10, 10,  5,  0,-10,
                                                        -10,  0,  0,  0,  0,  0,  0,-10,
                                                        -20,-15,-10,-10,-10,-10,-10,-20 };
    
    private static final int BLACK_BISHOP_BONUSES[] = { -20,-10,-10,-10,-10,-10,-10,-20,
                                                        -10,  0,  0,  0,  0,  0,  0,-10,
                                                        -10,  0,  5, 10, 10,  5,  0,-10,
                                                        -10,  5,  5, 10, 10,  5,  5,-10,
                                                        -10,  0, 10, 10, 10, 10,  0,-10,
                                                        -10, 10, 10, 10, 10, 10, 10,-10,
                                                        -10,  5,  0,  0,  0,  0,  5,-10,
                                                        -20,-15,-15,-15,-15,-15,-15,-20 };
    
    private static final int WHITE_ROOK_BONUSES[] = {   0,  0,  0,  5,  5,  0,  0,  0, 
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       5, 10, 10, 10, 10, 10, 10,  5,
                                                       0,  0,  0,  0,  0,  0,  0,  0 } ;
    
    private static final int BLACK_ROOK_BONUSES[] = {   0,  0,  0,  0,  0,  0,  0,  0,
                                                        5, 10, 10, 10, 10, 10, 10,  5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                       -5,  0,  0,  0,  0,  0,  0, -5,
                                                        0,  0,  0,  5,  5,  0,  0,  0 };
    
    private static final int WHITE_QUEEN_BONUSES[] = {  -20,-10,-10, -5, -5,-10,-10,-20,
                                                        -10, 0,  5,  0,  0,  0,  0,-10,
                                                        -10, 5,  5,  5,  5,  5,  0,-10,
                                                        0,   0,  5,  5,  5,  5,  0, -5,
                                                        -5,  0,  5,  5,  5,  5,  0, -5,
                                                        -10,  0,  5,  5,  5,  5,  0,-10,
                                                        -10,  0,  0,  0,  0,  0,  0,-10,
                                                        -20,-10,-10, -5, -5,-10,-10,-20  };
    
    private static final int BLACK_QUEEN_BONUSES[] = {  -20,-10,-10, -5, -5,-10,-10,-20,
                                                        -10,  0,  0,  0,  0,  0,  0,-10,
                                                        -10,  0,  5,  5,  5,  5,  0,-10,
                                                         -5,  0,  5,  5,  5,  5,  0, -5,
                                                          0,  0,  5,  5,  5,  5,  0, -5,
                                                        -10,  5,  5,  5,  5,  5,  0,-10,
                                                        -10,  0,  5,  0,  0,  0,  0,-10,
                                                        -20,-10,-10, -5, -5,-10,-10,-20 };

    private static final int WHITE_KING_BONUSES[] = {   15, 30, 10,  0,  0, 30, 20, 15,
                                                        20, 20,  0,  0,  0,  0, 20, 20,
                                                        -10,-20,-20,-20,-20,-20,-20,-10,
                                                        -20,-30,-30,-40,-40,-30,-30,-20,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30 };
 
    private static final int BLACK_KING_BONUSES[] = {   -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -30,-40,-40,-50,-50,-40,-40,-30,
                                                        -20,-30,-30,-40,-40,-30,-30,-20,
                                                        -10,-20,-20,-20,-20,-20,-20,-10,
                                                         20, 20,  0,  0,  0,  0, 20, 20,
                                                         15, 30, 10,  0,  0, 30, 20, 15 };
    
    // usage: PIECE_SQUARE_BONUSES[pieceTypeColor][squareSerial]
    private static final int PIECE_SQUARE_BONUSES[][] = { WHITE_KING_BONUSES,   BLACK_KING_BONUSES,
                                                          WHITE_QUEEN_BONUSES,  BLACK_QUEEN_BONUSES,
                                                          WHITE_ROOK_BONUSES,   BLACK_ROOK_BONUSES,
                                                          WHITE_BISHOP_BONUSES, BLACK_BISHOP_BONUSES,
                                                          WHITE_KNIGHT_BONUSES, BLACK_KNIGHT_BONUSES,
                                                          WHITE_PAWN_BONUSES,   BLACK_PAWN_BONUSES };
    
    private static final long CASTLED_KING = 0x4600000000000046L;   // castled king for purposes of king safety calculation
                                                                    // includes b rank, though this requires an additional king step.
                                                                    // no need to differentiate between black and white since it would be exceedingly rare for white king to be on the 8th rank behind a still
                                                                    // intact black pawn shield, and vice versa
    
    // by castled king position
    private static final long PAWN_SHIELD[] = { 0x0000000000000000L, 0x0000000000070700L, 0x00000000000E0E00L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000E0E000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0007070000000000L, 0x000E0E0000000000L, 0x0000000000000000L,
                                                0x0000000000000000L, 0x0000000000000000L, 0x00E0E00000000000L, 0x0000000000000000L };

    
    
    /**
     * Constructor for ChessEngine
     * @param board The current Chessboard for which to generate move
     * @param searchBoard   An additional Chessboard on which to perform searches
     */
    public ChessEngine(ZobristBoard board, ZobristBoard searchBoard) {
        this.board = board;
        this.searchBoard = searchBoard;
        this.killerMoveHistoryTable = new KillerMoveHistoryTable();
        this.moveComparator = new MoveComparator(killerMoveHistoryTable, true);
        this.moveComparatorNoHistory = new MoveComparator(killerMoveHistoryTable, false);
        this.transpositionTable = new TranspositionTable();
        this.running = false;
        this.displaySearchBoard = false;
    }
    
    /**
     * Constructor for ChessEngine
     * @param board The current Chessboard for which to generate move
     * @param searchBoard   An additional Chessboard on which to perform searches
     * @param searchBoardRenderer   A renderer for the searchboard for debugging purposes
     */
    public ChessEngine(ZobristBoard board, ZobristBoard searchBoard, BoardRenderer searchBoardRenderer) {
        this(board, searchBoard);
        this.searchBoardRenderer = searchBoardRenderer;
        this.displaySearchBoard = true;
    }
    
    
    /**
     * Interrupt the board from searching and induce it to return the next move immediately
     */
    public void interrupt() {
        interrupted = true;
    }
    
    /**
     * The main method used to get the optimal move, with default allowed processing time
     * @return A Move object containing the optimal next move
     */
    public Move getNextMove() {
        return getNextMove(allowedProcessingTime);
    }
    
    /**
     * The main method used to get the optimal move.
     * Uses iterative deepening to run the move search processing repeatedly at increasing depths
     * @param allowedProcessingTime Time in milliseconds the search is allowed to run before returning
     * @return A Move object containing the optimal next move
     */
    public Move getNextMove(int allowedProcessingTime) {
        interrupted = false;
        running = true;
        
        // if guidance from opening database exists, use it
        Move nextMoveFromDatabase = nextMoveFromDatabase();
        if (nextMoveFromDatabase != null) {
            running = false;
            return nextMoveFromDatabase;
        }
        
        searchBoard = board.getClone();
        //searchBoardRenderer.setChessboard(searchBoard);
        if (displaySearchBoard) repaint();

        // update the ply of the killer move history table
        for (int i = 0; i < (board.getPly() - killerMoveHistoryTable.getCurrentPly()); i++) {
            killerMoveHistoryTable.incrementPly();
        }
        
        long startTime = java.lang.System.currentTimeMillis();
        long quitTime = startTime + allowedProcessingTime;
        
        Move bestMove = null;
        for (int iteration = INITIAL_DEPTH; iteration <= DEPTH; iteration++) {
            System.out.println("****" + iteration + "*****");
            Move returnedMove = initialMoveGenerator(iteration, quitTime);
           
            if (java.lang.System.currentTimeMillis() > quitTime || interrupted) {
                // if a move has been found better than that marked as the best move at the previous level, return it
                if (returnedMove != null) {
                    running = false;
                    return returnedMove;
                }
                // else, return the move marked as the best move at the previous level
                running = false;
                return bestMove;
            }
            bestMove = returnedMove;
        }
        
        long endTime = java.lang.System.currentTimeMillis();
        System.out.println("Total time in milliseconds: " + (endTime - startTime));
        running = false;
        return bestMove;
    }

    /**
     * Search function at the initial level
     * @param targetDepth   Depth to search in ply
     * @param quitTime      Time of the system clock to return
     * @return              The best move
     */
    public Move initialMoveGenerator(int targetDepth, long quitTime) {
        long startTime = java.lang.System.currentTimeMillis();

        // get list of possible moves
        ArrayList<Move> possibleMoves = searchBoard.getPossibleMoves(searchBoard.getCurrentPlayer());
        Collections.sort(possibleMoves, moveComparator);
        transpositionFields = transpositionTable.get(searchBoard.hashValue);
        putBestMoveFirst(possibleMoves, transpositionFields);
        
        int max = Integer.MIN_VALUE + 1;
        Move bestMove = null;
        for (Move nextMove : possibleMoves) {
            System.out.print(nextMove.toString() + "   ");
            searchBoard.move(nextMove);
            int searchNodeVal = -searchNode(nextMove, Integer.MIN_VALUE + 1, -max, targetDepth, quitTime);
            nextMove.setEvaluation(searchNodeVal);
            searchBoard.undoLastMove();
            System.out.println(searchNodeVal);
            if (searchNodeVal > max) {
                max = searchNodeVal;
                bestMove = nextMove;
            }
            if (java.lang.System.currentTimeMillis() > quitTime || interrupted) {
                break;
            }
        }
        
        // only update transposition table if search wasn't cut short
        if (java.lang.System.currentTimeMillis() < quitTime && !interrupted) {
            updateTranspositionTable(max, DEPTH, bestMove, TypeOfScore.EXACT);
        }
        
        if (bestMove != null) {
            bestMove.setBoard(board);  // must make move on original board, not search board
        }
        
        System.out.println("--------------------------------------");
        long endTime = java.lang.System.currentTimeMillis();
        System.out.println("Total time in milliseconds: " + (endTime - startTime));
        return bestMove;
    }
    
    /**
     * A recursive helper method which cycles through all possible responses to move just made, calling itself each time.
     * Note that move is made before calling this method, and unmade after returning from this method. 
     * The base case of this recursive method evaluates the most distant
     * potential moves, returning alternately the max and min of the int
     * evaluation down the stack, simulating the two players each alternately
     * making the most advantageous and least advantageous moves for the AI.
     *
     * @param searchMove The move being evaluated
     * @param alpha The previous max that the current player can obtain from previous moves
     * @param beta  The previous min that the opposing player can obtain from previous moves
     * @param targetDepth   The target search depth in ply
     * @param quitTime  The system time to quit and return
     * @return The evaluation score for the move being searched to the given depth
     */
    
    private int searchNode(Move searchMove, int alpha, int beta, int targetDepth, long quitTime) {
        if (displaySearchBoard) repaint();
        int originalAlpha = alpha;
        int currentPlayer = searchBoard.getCurrentPlayer();
        int currentDepth = searchBoard.getPly() - board.getPly();        

        // check whether board has already been evaluated to the proper depth; if so, skip evaluation process
        transpositionFields = transpositionTable.get(searchBoard.hashValue);
        if (transpositionFields != null && transpositionFields.depth >= targetDepth - currentDepth - ACCEPTABLE_LOSS_OF_DEPTH_IN_TRANSPOSITION) {
            if (transpositionFields.typeOfScore == TypeOfScore.EXACT) {
                return transpositionFields.score;
            }
            else if (transpositionFields.typeOfScore == TypeOfScore.FAIL_LOW) {
                alpha = Integer.max(alpha, transpositionFields.score);
            }
            else if (transpositionFields.typeOfScore == TypeOfScore.FAIL_HIGH) {
                beta = Integer.min(beta, transpositionFields.score);
            }
            if (alpha >= beta) {
                if (!searchMove.isCapture()) {
                     killerMoveHistoryTable.addMove(searchMove);
                 }
                return transpositionFields.score;
            }
        }           
        
        if (searchBoard.getPieceSet(currentPlayer + Chessboard.KING) == 0) {
            return Integer.MIN_VALUE + 2 + currentDepth;  // farther checkmate is preferable to near checkmate  
        }

        // threefold repetition is draw
        if (searchBoard.isRepetition(3)) {
            return DRAW_VALUE;
        }

        // null move pruning
        /*if (!searchBoard.isInCheck(currentPlayer)) {
            // check whether null move is enough for alpha pruning
            int nullMoveScore = evaluateBoard(searchBoard);
            if (nullMoveScore >= beta) {
                return beta;
            }
            alpha = Integer.max(alpha, nullMoveScore); 
        } */


        if (currentDepth >= targetDepth) {
            if (searchMove.isCapture() || searchBoard.isInCheck(currentPlayer)  ) {
               return quiescence(alpha, beta, targetDepth + ADDITIONAL_DEPTH_FOR_QUIESCENCE, quitTime);
            }
            return evaluateBoard(searchBoard);
        }
        
        ArrayList<Move> possibleMoves = searchBoard.getPossibleMoves(currentPlayer);
        Collections.sort(possibleMoves, moveComparator);
        putBestMoveFirst(possibleMoves, transpositionFields);
        
        Move bestMove = possibleMoves.get(0);
        int bestValue = Integer.MIN_VALUE + 1;
        
        for (Move nextMove : possibleMoves) {
            searchBoard.move(nextMove);
            if (displaySearchBoard) repaint();
            int searchNodeVal = -searchNode(nextMove, -beta, -alpha, targetDepth, quitTime);
            searchBoard.undoLastMove();
            if (displaySearchBoard) repaint();
            
            if (java.lang.System.currentTimeMillis() > quitTime || interrupted) {
                return Integer.MIN_VALUE;
            }
        
            alpha = Integer.max(bestValue, alpha);
            if (searchNodeVal > bestValue) {
                bestValue = searchNodeVal;
                bestMove = nextMove;
            }
            // alpha beta pruning
            if (searchNodeVal >= beta) {
                if (!nextMove.isCapture()) {
                    killerMoveHistoryTable.addMove(nextMove);
                }
                break;
            }
        }
        
        // update transposition table
        TypeOfScore typeOfScore = TypeOfScore.EXACT;
        if (bestValue <= originalAlpha) {
            typeOfScore = TypeOfScore.FAIL_HIGH;
        }
        else if (bestValue >= beta) {
            typeOfScore = TypeOfScore.FAIL_LOW;
        }
        updateTranspositionTable(bestValue, targetDepth - currentDepth, bestMove, typeOfScore);
        return bestValue;
    }
    
    /**
     * Keeps searching until quiet (non capture, check) moves are found.
     * @param alpha The previous max that the current player can obtain from previous moves
     * @param beta  The previous min that the opposing player can obtain from previous moves
     * @param targetDepth   The target search depth in ply
     * @param quitTime  The system time to quit and return
     * @return The evaluation score for the move being searched to the given depth
     */
    private int quiescence(int alpha, int beta, int targetDepth, long quitTime) {
        if (displaySearchBoard) repaint();
       
        int originalAlpha = alpha;
        int currentPlayer = searchBoard.getCurrentPlayer();
        int currentDepth = searchBoard.getPly() - board.getPly();        

        // check whether board has already been evaluated to the proper depth; if so, skip evaluation process
        transpositionFields = transpositionTable.get(searchBoard.hashValue);
        if (transpositionFields != null && transpositionFields.depth >= targetDepth - currentDepth - ACCEPTABLE_LOSS_OF_DEPTH_IN_TRANSPOSITION) {
            if (transpositionFields.typeOfScore == TypeOfScore.EXACT) {
                return transpositionFields.score;
            }
            else if (transpositionFields.typeOfScore == TypeOfScore.FAIL_LOW) {
                alpha = Integer.max(alpha, transpositionFields.score);
            }
            else if (transpositionFields.typeOfScore == TypeOfScore.FAIL_HIGH) {
                beta = Integer.min(beta, transpositionFields.score);
            }
        }
        
        if (searchBoard.getPieceSet(currentPlayer + Chessboard.KING) == 0) {
            return Integer.MIN_VALUE + 2 + currentDepth;  // farther checkmate is preferable to near checkmate  
        }
        
        // threefold repetition is draw
        if (searchBoard.isRepetition(3)) {
            return DRAW_VALUE;
        }
       
        int nullMoveScore = evaluateBoard(searchBoard);
        
        // base case
        if (currentDepth >= targetDepth) {
            return nullMoveScore;
        }
        
        if (!searchBoard.isInCheck(currentPlayer)) {
            // check whether null move is enough for alpha pruning
            if (nullMoveScore >= beta) {
                return beta;
            }
            alpha = Integer.max(alpha, nullMoveScore); 
        }
        
        ArrayList<Move> possibleMoves = searchBoard.getPossibleMoves(currentPlayer);
        Collections.sort(possibleMoves, moveComparatorNoHistory);   
        putBestMoveFirst(possibleMoves, transpositionFields);
        Move bestMove = possibleMoves.get(0);
        int bestValue = nullMoveScore;

        for (Move nextMove : possibleMoves) {
            // evaluate only captures
            if (!nextMove.isCapture() && !searchBoard.isInCheck(currentPlayer) ) {
                continue;
            }
            
            searchBoard.move(nextMove);
            if (displaySearchBoard) repaint();

            int searchNodeVal = -quiescence(-beta, -alpha, targetDepth, quitTime);
            searchBoard.undoLastMove();
            if (displaySearchBoard) repaint();
            
            if (java.lang.System.currentTimeMillis() > quitTime || interrupted) {
                return Integer.MIN_VALUE;
            }
            
            if (searchNodeVal >= beta) {
                return beta;
            }
            
            alpha = Integer.max(bestValue, alpha);
            if (searchNodeVal > bestValue) {
                bestValue = searchNodeVal;
                bestMove = nextMove;
            }
        }
        
        // update transposition table
        TypeOfScore typeOfScore = TypeOfScore.EXACT;
        if (bestValue <= originalAlpha) {
            typeOfScore = TypeOfScore.FAIL_HIGH;
        }
        else if (bestValue >= beta) {
            typeOfScore = TypeOfScore.FAIL_LOW;
        }
        
        updateTranspositionTable(bestValue, targetDepth - currentDepth, bestMove, typeOfScore); 
        Collections.sort(possibleMoves);
        return bestValue;
    }
  
    
    /**
     * Gets the board for searching potential moves
     * @return the searchboard
     */
    public Chessboard getSearchBoard() {
        return searchBoard;
    }
    
    /**
     * Identifies whether the engine is running
     * @return  True if the engine is running, false if it is not
     */
    public boolean isRunning() {
        return running;
    }
    
    /**
     * Gets next move from opening book database derived from high Elo level games.
     * Evaluates moves based upon the win ratio resulting from the move, as well as the count of games which utilize the move.
     * @return The next Move which is most optimal based on the opening book
     */
    private Move nextMoveFromDatabase() {
        String movetext = "";
        PGNGameTreeLookup lookup = new PGNGameTreeLookup();
        if (lookup.lookup(new PGNGame(board.getMoves()))) {
            double bestScore = 0;
            ArrayList<MoveResults> moveResults = lookup.getChildrensResults();
            for (MoveResults result : moveResults) {
                int totalGames = result.wins + result.losses + result.draws;
                double ratioWins = (result.wins + (result.draws * DRAW_MULTIPLIER)) / totalGames;

                // cube ratio of wins so is not weighted so heavily to the numerical count
                // also could do weighted random to avoid always making same response
                double score = result.wins * ratioWins * ratioWins * ratioWins;

                System.out.println(result.movetext + " - wins: " + result.wins + " losses: " + result.losses + " draws: " + result.draws);
                System.out.println("      Total games: " + totalGames + " ratio wins: " + ratioWins + "  Score: " + score);
                if (score > bestScore) {
                    bestScore = score;
                    movetext = result.movetext;
                }
            }
            System.out.println("----------------------------------------------------");
        } else {
            return null;
        }

        try {
            return new Move(this.board.getPly(), movetext, this.board);
        } catch (InvalidMoveException ime) {
            return null;
        }
    }

    /**
     * Evaluates the relative strength of a player on the board.
     * @param board The Chessboard to evaluate
     * @return A relative evaluation of the board from player's perspective.
     * Positive values indicate player's advantage, negative indicate opponent's advantage.
     */
    public static int evaluateBoard(Chessboard board) {
        int evaluation = 0;
        int player = board.getCurrentPlayer();
        
        if (!board.sufficientMaterialToCheckmate()) {
            return DRAW_VALUE;
        }
        
        if (Long.bitCount(board.getPieceSet(Chessboard.BISHOP + player)) >= 2) {
            evaluation += DOUBLE_BISHOP_BONUS;
        }
        if (Long.bitCount(board.getPieceSet(Chessboard.BISHOP + 1 - player)) >= 2) {
            evaluation -= DOUBLE_BISHOP_BONUS;
        }
        
        evaluation += evaluatePawnStructure(board, player);
        
        // evaluate each piece type
        for (int pieceType = Chessboard.KING; pieceType <= Chessboard.PAWN; pieceType += 2) {
            // add piece values for player, subtract piece values for opponent
            Long playersPieceSet = board.getPieceSet(pieceType + player);
            Long opponentsPieceSet = board.getPieceSet(pieceType + 1 - player);
            int playersPieces = Long.bitCount(playersPieceSet);
            int opponentsPieces = Long.bitCount(opponentsPieceSet);
            evaluation += playersPieces * Piece.getValue(pieceType);
            evaluation -= opponentsPieces * Piece.getValue(pieceType);

            // add points for mobility and connectivity
            if (pieceType >= Chessboard.ROOK || board.getPly() > 20) {  // consider removing this condition
                for (int i = 0; i < playersPieces; i++) {
                    long currentPosition = Long.lowestOneBit(playersPieceSet);
                    int currentPositionSerial = Square.toSerial(currentPosition);
                    long potentialMovesExcludingCastle = Piece.getPotentialMovesExcludingCastle(pieceType + player, currentPositionSerial, board);
                    long possibleMovesExcludingCastle = Piece.getPossibleMovesExcludingCastle(pieceType + player, currentPositionSerial, board, potentialMovesExcludingCastle);
                    evaluation += Long.bitCount(possibleMovesExcludingCastle) * MOBILITY_MULTIPLIER;
                    // lesser value pieces have higher bonuses for attacking and supporting
                    evaluation += Long.bitCount(Piece.getPotentialSupportingMoves(potentialMovesExcludingCastle, board)) * CONNECTIVITY_MULTIPLIER * (Math.log10(pieceType + 2) + 1);
                    evaluation += Long.bitCount(Piece.getPossibleAttackingMoves(potentialMovesExcludingCastle, board)) * ATTACK_MULTIPLIER * (Math.log10(pieceType + 2) + 1);
                    evaluation += Long.bitCount(possibleMovesExcludingCastle & Chessboard.CENTER4) * CENTER4_MULTIPLIER;
                    evaluation += Long.bitCount(possibleMovesExcludingCastle & Chessboard.CENTER16) * CENTER16_MULTIPLIER;
                    evaluation += PIECE_SQUARE_BONUSES[pieceType + player][currentPositionSerial];

                    playersPieceSet -= currentPosition;
                }
                for (int i = 0; i < opponentsPieces; i++) {
                    long currentPosition = Long.lowestOneBit(opponentsPieceSet);
                    int currentPositionSerial = Square.toSerial(currentPosition);
                    long potentialMovesExcludingCastle = Piece.getPotentialMovesExcludingCastle(pieceType + 1 - player, currentPositionSerial, board);
                    long possibleMovesExcludingCastle = Piece.getPossibleMovesExcludingCastle(pieceType + 1 - player, currentPositionSerial, board, potentialMovesExcludingCastle);
                    evaluation -= Long.bitCount(possibleMovesExcludingCastle) * MOBILITY_MULTIPLIER;
                    evaluation -= Long.bitCount(Piece.getPotentialSupportingMoves(potentialMovesExcludingCastle, board)) * CONNECTIVITY_MULTIPLIER * (Math.log10(pieceType + 2) + 1);
                    evaluation -= Long.bitCount(Piece.getPossibleAttackingMoves(potentialMovesExcludingCastle, board)) * ATTACK_MULTIPLIER * (Math.log10(pieceType + 2) + 1);
                    evaluation -= Long.bitCount(possibleMovesExcludingCastle & Chessboard.CENTER4) * CENTER4_MULTIPLIER;
                    evaluation -= Long.bitCount(possibleMovesExcludingCastle & Chessboard.CENTER16) * CENTER16_MULTIPLIER;
                    evaluation -= PIECE_SQUARE_BONUSES[pieceType + 1 - player][currentPositionSerial];

                    opponentsPieceSet -= currentPosition;
                }
            }

            // king safety
            evaluation += evaluateKingSafety(board, player);
            evaluation -= evaluateKingSafety(board, 1 - player);

        }
        return evaluation;
    }

    /**
     * Calculates a bonus or penalty for king safety for one player.  Should be called on both players.
     * @param board The Chessboard on which to evaluate the safety of the king
     * @param player The player whose king safety to evaluate (a positive
     * score indicates a relative advantage for this player)
     * @return A bonus or penalty for king safety measured in centipawns
     */
    public static int evaluateKingSafety(Chessboard board, int player) {
        int evaluation = 0;
        long kingPosition = board.getPieceSet(Chessboard.KING + player);
        int kingPositionSerial = Square.toSerial(kingPosition);
        if ((kingPosition & CASTLED_KING) != 0) {
            evaluation += Long.bitCount(board.getPieceSet(Chessboard.PAWN + player) & PAWN_SHIELD[kingPositionSerial]) * PAWN_SHIELD_BONUS;
        } else {
            boolean kingsideCastlingRights = !board.castlePiecesHaveMoved(0, player);
            boolean queensideCastlingRights = !board.castlePiecesHaveMoved(1, player);
            if (kingsideCastlingRights && queensideCastlingRights) {
                evaluation += BOTH_CASTLING_RIGHTS_VALUE;
            } 
            else if (kingsideCastlingRights || queensideCastlingRights) {
                evaluation += ONE_CASTLING_RIGHTS_VALUE;
            }
        }
        long squaresAdjacentToKing = Chessboard.ADJACENT_SQUARE_BLOCK[kingPositionSerial];
        while (squaresAdjacentToKing != 0) {
            int squareSerial = Square.toSerial(squaresAdjacentToKing);
            if (Square.isAttacked(squareSerial, board, player)) {
                evaluation -= SQUARE_ADJACENT_TO_KING_ATTACKED_PENALTY;
            }
            squaresAdjacentToKing -= Square.toBitwise(squareSerial);
        }
        return evaluation;
    }
    
    
    /**
     * Calculate relative penalties or bonuses for both players' pawn structure, including passed pawns, doubled and isolated pawns
     * @param board The board on which to evaluate pawn structure
     * @param player    The player from whose perspective to evaluate (a positive score indicates a relative advantage for this player)
     * @return  Relative penalty or bonus for player in centipawns
     */
    public static int evaluatePawnStructure(Chessboard board, int player) {
        int score = 0;
        long playerPawnSet = board.getPieceSet(Chessboard.PAWN + player);
        long opponentPawnSet = board.getPieceSet(Chessboard.PAWN + 1 - player);
        
        long playersPawnsByFile[] = new long[8];
        long opponentsPawnsByFile[] = new long[8];
        
        for (int file = 0; file < 8; file++) {
            playersPawnsByFile[file] = playerPawnSet & Chessboard.FILES[file];
            opponentsPawnsByFile[file] = opponentPawnSet & Chessboard.FILES[file];
        }
        
        for (int file = 0; file < 8; file++) {
            // penalty for doubled pawns
            score -= Math.max(Long.bitCount(playersPawnsByFile[file]) - 1, 0) * DOUBLED_PAWN_PENALTY;
            score += Math.max(Long.bitCount(opponentsPawnsByFile[file]) - 1, 0) * DOUBLED_PAWN_PENALTY;

            // penalty for isolated pawns
            if ((file == 0 || Long.bitCount(playersPawnsByFile[file - 1]) == 0) && 
                              Long.bitCount(playersPawnsByFile[file])     >  0 && 
                (file == 7 || Long.bitCount(playersPawnsByFile[file + 1]) == 0)) {
                score -= ISOLATED_PAWN_PENALTY;
            }
            if ((file == 0 || Long.bitCount(opponentsPawnsByFile[file - 1]) == 0) && 
                              Long.bitCount(opponentsPawnsByFile[file])     >  0 && 
                (file == 7 || Long.bitCount(opponentsPawnsByFile[file + 1]) == 0)) {
                score += ISOLATED_PAWN_PENALTY;
            }
       
            // bonus for passed pawns
            if (Long.bitCount(playersPawnsByFile[file]) > 0) {
                int pawnRank = Square.getRank(Square.toSerial(playersPawnsByFile[file]));
                if ((file == 0 || Long.bitCount(opponentsPawnsByFile[file - 1] & Chessboard.RANKS_AHEAD[player][pawnRank]) == 0) && 
                                  Long.bitCount(opponentsPawnsByFile[file]     & Chessboard.RANKS_AHEAD[player][pawnRank]) == 0  &&
                    (file == 7 || Long.bitCount(opponentsPawnsByFile[file + 1] & Chessboard.RANKS_AHEAD[player][pawnRank]) == 0)) {
                    score += PASSED_PAWN_BONUS;
                }
            }
            if (Long.bitCount(opponentsPawnsByFile[file]) > 0) {
                int pawnRank = Square.getRank(Square.toSerial(opponentsPawnsByFile[file]));
                if ((file == 0 || Long.bitCount(playersPawnsByFile[file - 1] & Chessboard.RANKS_AHEAD[1 - player][pawnRank]) == 0) && 
                                  Long.bitCount(playersPawnsByFile[file]     & Chessboard.RANKS_AHEAD[1 - player][pawnRank]) == 0  &&
                    (file == 7 || Long.bitCount(playersPawnsByFile[file + 1] & Chessboard.RANKS_AHEAD[1 - player][pawnRank]) == 0)) {
                    score += PASSED_PAWN_BONUS;
                }
            }
        }
        
        return score;
    }

    /**
     * Repaints the search board.
     */
    private void repaint() {
        searchBoardRenderer.paintComponent(searchBoardRenderer.getGraphics());
    }

    /**
     * Puts the best next move (identified by a prior search stored in the transposition table) at the front of the list to be searched, in order to facilitate alpha-beta cutoffs.
     * @param possibleMoves     An ArrayList containing a list of the possible moves from the current position
     * @param transpositionFields   The results of a transposition table search of the current position
     */
    private void putBestMoveFirst(ArrayList<Move> possibleMoves, TranspositionFields transpositionFields) {
        if (transpositionFields != null) {
            Move bestMove = transpositionFields.bestMove;
            for (Move move : possibleMoves) {
                if (move.equals(bestMove)) {
                    bestMove = move;
                    possibleMoves.remove(move);
                    possibleMoves.add(0, bestMove);
                    break;
                }
            }
        }
    }
    
    /**
     * Updates the transposition table with search results from a given position
     * @param moveValue The evaluation score in centipawns of the given position
     * @param depth     The depth in ply to which the position has been evaluated
     * @param bestMove  The best move for this position, as evaluated to the given depth
     * @param typeOfScore   Whether the result is an exact result, lower bound, or upper bound
     */
    private void updateTranspositionTable(int moveValue, int depth, Move bestMove, TypeOfScore typeOfScore) { 
        transpositionFields = transpositionTable.get(searchBoard.hashValue);
        if (transpositionFields == null || transpositionFields.depth <= depth) {
            transpositionTable.put(searchBoard.hashValue, new TranspositionFields(moveValue, depth, bestMove, transpositionTable.getSerial(), typeOfScore));
        }
    }
}


/**
 * A comparator used to sort moves by potential value, putting captures first, 
 * followed by frequently used cutoffs in the killer move table if available, 
 * or if not, priority is given moves moving toward the center of the board.
 * @author Christopher Stieg
 */
class MoveComparator implements Comparator<Move> {
    private final KillerMoveHistoryTable killerMoveHistoryTable;
    private final boolean checkKillerMoveTable;

    /**
     * Constructor for MoveComparator
     * @param killerMoveHistoryTable    Table of killer (cutoff) move history
     * @param checkKillerMoveTable      True to evaluate non-captures by killer move history, false to evaluate by direction of move (toward center preferred)
     */
    public MoveComparator(KillerMoveHistoryTable killerMoveHistoryTable, boolean checkKillerMoveTable) {
        this.killerMoveHistoryTable = killerMoveHistoryTable;
        this.checkKillerMoveTable = checkKillerMoveTable;
    }

    /**
     * Compares two moves
     * @param a First move to be compared
     * @param b Second move to be compared
     * @return  Positive integer if Move b is of greater value than Move a; negative integer if Move a is of greater value than Move b; 0 if the two moves are of equal value.
     */
    @Override
    public int compare(Move a, Move b) {
        // captures come next
        boolean aCapture = a.isCapture();
        boolean bCapture = b.isCapture();
        if (!aCapture && !bCapture) {
            if (checkKillerMoveTable) {
               return killerMoveHistoryTable.getResults(b) - killerMoveHistoryTable.getResults(a);
            }
            return Chessboard.DISTANCE_FROM_CENTER[a.getDestinationSerial()] - Chessboard.DISTANCE_FROM_CENTER[b.getDestinationSerial()];
        }
        if (aCapture && !bCapture) {
            return -1;
        }
        if (!aCapture && bCapture) {
            return 1;
        }

        // both capture - capture of higher pieces have priority, capture BY lower pieces have secondary priority
        int thisValue = ((12 - a.getCapturedPieceTypeColor()) * 100) + a.getPieceTypeColor();
        int moveValue = ((12 - b.getCapturedPieceTypeColor()) * 100) + b.getPieceTypeColor();
        return moveValue - thisValue;
    }
}